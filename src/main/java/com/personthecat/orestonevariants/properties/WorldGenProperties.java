package com.personthecat.orestonevariants.properties;

import com.google.common.collect.ImmutableSet;
import com.personthecat.orestonevariants.config.Cfg;
import com.personthecat.orestonevariants.util.InvertableSet;
import com.personthecat.orestonevariants.util.Lazy;
import com.personthecat.orestonevariants.util.Range;
import com.personthecat.orestonevariants.world.WildcardBiome;
import net.minecraft.block.Block;
import net.minecraft.block.state.IBlockState;
import net.minecraft.world.biome.Biome;
import org.hjson.JsonArray;
import org.hjson.JsonObject;
import org.hjson.JsonValue;

import java.util.*;

import static com.personthecat.orestonevariants.util.CommonMethods.*;
import static com.personthecat.orestonevariants.util.HjsonTools.*;

public class WorldGenProperties {
    /** The ratio of dense:normal variants. */
    public final double denseRatio;
    /** The vein 'count' to spawn, according to WorldGenMinable. */
    public final int size;
    /** The number of tries per chunk to spawn veins. */
    public final int count;
    /** The chance that any try will succeed. */
    public final double chance;
    /** A range of acceptable heights for this ore to spawn. */
    public final Range height;
    /** A unique ID for the block generated by these properties. */
    public final Lazy<Integer> ID;

    /** A list of biomes for this ore to spawn in, lazily initialized. */
    public final Lazy<InvertableSet<Biome>> biomes;
    /** A list of all dimensions for this ore to spawn in. */
    public final InvertableSet<Integer> dimensions;

    /** Allows WorldGenProperties to be retrieved from JsonObjects. */
    public WorldGenProperties(String lookup, JsonObject json) {
        this(lookup, json, getObjectOrNew(json, "biomes"));
    }

    /** Separates the `biomes` object out of `main` to retrieve multiple elements from it. */
    private WorldGenProperties(String lookup, JsonObject main, JsonObject biomes) {
        this(
            lookup,
            getFloatOr(main, "denseChance", (float) Cfg.DenseCat.chance),
            getIntOr(main, "size", 8),
            getIntOr(main, "count", 2),
            getFloatOr(main, "chance", 1.0F),
            getRangeOr(main, "height", new Range(0, 32)),
            getStringArrayOrEmpty(biomes, "names"),
            getStringArrayOrEmpty(biomes, "types"),
            getBoolOr(main, "blacklistBiomes", false),
            getIntArrayOrEmpty(main, "dimensions"),
            getBoolOr(main, "blacklistDimensions", false)
        );
    }

    /** Primary constructor. */
    public WorldGenProperties(
        String lookup,
        double denseRatio,
        int size,
        int count,
        double chance,
        Range height,
        List<String> biomes,
        List<String> biomeTypes,
        boolean blacklistBiomes,
        int[] dimensions,
        boolean blacklistDims
    ) {
        // Todo: Consider porting stone clusters from Cave Generator for this.
        if (Cfg.WorldCat.largeClusters) {
            if (size < 4) {
                count *= 20; // Small veins need higher frequencies.
            } else if (count > 1) {
                count /= 2;
                size = 45;
            } else {
                size = 25;
            }
        }

        this.ID = new Lazy<>(() -> getStateId(lookup));
        this.denseRatio = denseRatio;
        this.size = size;
        this.count = count;
        this.chance = chance;
        this.height = height;
        this.biomes = new Lazy<>(() -> getAllBiomes(biomes, biomeTypes, blacklistBiomes));
        this.dimensions = getDimSet(dimensions, blacklistDims);
    }

    // Todo: Still comparing speed differences between mapped gen vs unmapped.
    public boolean canSpawn(int dim, Biome b) {
        return dimensions.check(dim) && biomes.get().check(b);
    }

    /** Attempts to lookup a blockstate and retrieve its state ID. */
    private static int getStateId(String lookup) {
        final IBlockState state = getBlockState(lookup)
            .orElseThrow(() -> runExF("No block state found for: {}.", lookup));
        return Block.getStateId(state);
    }

    private static InvertableSet<Biome> getAllBiomes(List<String> names, List<String> types, boolean blacklist) {
        final ImmutableSet.Builder<Biome> builder = new ImmutableSet.Builder<>();
        names.forEach(name -> builder.add(getBiome(name)
            .orElseThrow(() -> noBiomeNamed(name))));
        types.forEach(type -> builder.addAll(Arrays.asList(getBiomes(getBiomeType(type)))));
        if (!Cfg.WorldCat.biomeSpecific) {
            blacklist = true; // Strange placement
        }
        return InvertableSet.wrap(builder.build()).setBlacklist(blacklist);
    }

    private static InvertableSet<Integer> getDimSet(int[] dimensions, boolean blacklist) {
        final ImmutableSet.Builder<Integer> builder = new ImmutableSet.Builder<>();
        for (int i : dimensions) {
            builder.add(i);
        }
        return InvertableSet.wrap(builder.build()).setBlacklist(blacklist);
    }

    /** Converts an array of JsonObjects to a List of WorldGenProperties. */
    public static List<WorldGenProperties> list(String lookup, JsonArray array) {
        final List<WorldGenProperties> list = new ArrayList<>();
        for (JsonValue value : array) {
            list.add(new WorldGenProperties(lookup, value.asObject()));
        }
        return list;
    }
}